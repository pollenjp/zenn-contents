---
title: "理想的なIaC管理"
---

本セクションでは「環境構築とデプロイ」レイヤが継続的なツール開発を支えるためにはどのような姿であるべきかを考えていきます。

[![Image from Gyazo](https://i.gyazo.com/9be5519fd4f9e12bbf652ca7d1efcca0.png)](https://gyazo.com/9be5519fd4f9e12bbf652ca7d1efcca0)

## 求められる性質

まず、「環境構築とデプロイ」のレイヤに求められる性質のうち、上のレイヤに特に大きな影響を及ぼすと考えるものを 3 つに絞って上げたいと思います。

- 再構築性 (Reconstructability)
- 可監査性 (Auditability)
- デプロイ容易性 (Deployability)

### 再構築性と可監査性 (Reconstructability & Auditability)

「一度デプロイした環境をゼロから再構築できる性質」、それをここでは「再構築性 (Reconstructability)」と呼ぶことにします[^reconstructability]。

[^reconstructability]: ソフトウェア品質を表す指標 (Ilities) の定義は人によって異なることがあるためこのような表現をしています。

前セクションで手動デプロイした例を上げましたが、あのままでは再構築性が皆無です。 なにかの弾みで環境が吹き飛んだときに同じ環境を作れる保証が無いからです。
依存関係のアプリケーションからデータベースまでをゼロから構築するスクリプトは最低限必要でしょう。

スクリプト化することは以下のような恩恵をもたらします。

- バージョン管理ができる
- 可逆性を持つ[^software_can_be_rollback] (何かあったときに過去のバージョンに戻ることができる)
- 戻る技術は安全に進む技術であり、我々に改善の手を加える勇気をもたらす[^rollbackability_is_a_safe_technology_to_move_forward]

[^software_can_be_rollback]:
    しかし, ほとんどの決定はそのようなものではなく, 変更可能で, 可逆的で, 双方向のドアです.
    もしあなたがこうしたタイプ 2 の決定で最適でない決定をしてしまったとしても, その結果に長く耐える必要はありません.
    扉を開けて, また戻ればいいのです.
    タイプ 2 の決定は, 判断力の高い個人や少人数のグループが迅速に行えますし, そうすべきです.
    (ジェフ・ベゾス、Amazon 株主への手紙（2015） 『モノリスからマイクロサービスへ』)

[^rollbackability_is_a_safe_technology_to_move_forward]: [基調講演: 私の開発ワークフロー (和田 卓人) - REDMINE JAPAN Vol.2 - YouTube](https://www.youtube.com/watch?v=IQ7lDefJLtk&t=1135s&ab_channel=RedmineJapan)

まず、スクリプト化されているということは、どうやってその環境を作り出したかが正確に記述されているということです (正確性については IaC の項目で後述)。
最新のコミットが現在の環境を表すことは、そこ環境を **reviewable** にし、 **Auditability (可監査性)** を与えたことになります。
一人で開発していると誰も見てくれるはずがないとふてくされるかもしれませんが、少なくとも 1 ヶ月後のあなたは、過去の自分に感謝し、それを市場の変化と戦う武器としていることでしょう。
また、誰も見てくれないと決めつけるのは早計です。auditability を担保したシステムは透明性を持ち、理解をしたいと思っている隠れた人々には届くはずです。やる気はあるのにその機会を与えない損失は大きいです。

また、「可逆」であるということは「環境構築とデプロイ」レイヤ自身が最適化やセキュリティ要求を満たすために、インフラ構成を変更するリスクを減らし、様々な環境を試す機会を与えます。
これは「ツール開発」レイヤにとっても同じことです。いくらでも複製可能で、 廃棄容易な環境 (Disposability) は思い切った変更や動作確認を促進させるでしょう。

すなわち、再構築性がもたらす可逆性はエンジニアに変更することへの **不安を勇気に変える役割** をもつといえるでしょう。

### デプロイ容易性 (Deployability)

デプロイ容易性 (Deployability) とは、端的に言うとできるだけコストを抑え、どれだけスムーズにコミットされた内容を本番に反映できるかということです。

前セクションの例で我々は最低限の要件のみを定義し開発をスタートさせました。 アジャイル的な開発では頻繁なフィードバックサイクルを回すために、小さな改修を反復的でインクリメンタルに行うべきです。
複数の機能を追加してからまとめてリリースするよりも、マイナーな機能単位でリリースしたほうがこのサイクルはよく周ります。

この要求に応えるには当然、「環境構築とデプロイ」レイヤの **デプロイコストはほぼゼロにしないといけません**。

更新するためのコマンドを用意しておくこともありですが、デプロイ先のサーバーに近づきすぎると、サーバーへの依存 (Device-Dependence) の強い処理を不意に仕込み安くなってしまうため、抽象化できているとなお良いです。
Continuous Deployment までできれば理想的ですが、その準備の再構築性も確保しておきましょう。

## IaC

ここまで読んでいる人は既に理解していそうですが、 IaC とは Infrastructure as Code の略で、インフラの状態 (ハードウェア ～ サーバー内部構成等) を記述的に表現し、構築・設定・管理を自動化することを指します。

「環境構築とデプロイ」レイヤに求められる役割を果たすのに最適な概念と言えるでしょう。
実際に IaC を得意とした有名なツールはいくつかあり以下のようなものが挙げられます。

- Kubernetes (K8s)
- Terraform
- AWS CDK (AWS CloudFormation)
- Ansible
- Puppet
- Chef

本書では具体的なツールの使い方は扱いませんが、これらのツールをうまく使いこなすことで、「環境構築とデプロイ」の役割を満たすことができます。
設定さえ書いてしまえば自動でデプロイされるため、定期的に新しい環境に展開することで再構築性の保証確認が行えます (先述した正確性について)。

また、ツール作成時に、アプリケーション開発者は設定値を定数や config ファイルとして管理してコードリポジトリに push したくなることでしょう。 しかし、[The Twelve-Factor App「III. Config」](https://12factor.net/config)にある通り、アプリケーション側にデプロイ先に関連のある情報を含むことは悪手とされています。
そこで、IaC の基盤を作っておくと、アプリごとのデプロイ先依存の情報は IaC 側で管理すればよいという棲み分けが明確になり、環境への依存から解放されたツール開発が可能になります。

[![Image from Gyazo](https://i.gyazo.com/f66f4f300f0ec5a377f28fe074f1fb18.png)](https://gyazo.com/f66f4f300f0ec5a377f28fe074f1fb18)

## 組織編成的な視点

まず、IaC を正しく行うにはそのレイヤーのついての **正しい知識を持ったエンジニア** がそこにアプリをデプロイする **ツール全般をリード** する必要があります。
別にデプロイを必要とするツールのソースコードを全て読んでレビューしろという話ではありません。 ただ、上の図で示す通り、ツールとデプロイ環境との間を線でつなぐ役割は担って上げる必要があります[^teaching]。
その中で、例えばアプリケーション側で[The Twelve-Factor App「III. Config」](https://12factor.net/config)周りの違反があれば、適切なコミュニケーションのもと良いコードへの理解を高めて行ってもらうのが理想でしょう。

[^teaching]: 属人性の観点から、IaC 側にデプロイを組み込んだ際のコード差分はツール開発者と一緒に確認し、壁を感じさせない知識共有ができるとよいでしょう。

これらを怠れば、限られたの数エンジニアの中で作り出すツールの数はスケールせず、運用コストばかり膨らんでいきます。 次のセクションでは、IaC が存在しない現場の崩壊のシナリオについて考えてみます。

[![Image from Gyazo](https://i.gyazo.com/b6397026ee6302430ede98405446307e.png)](https://gyazo.com/b6397026ee6302430ede98405446307e)
